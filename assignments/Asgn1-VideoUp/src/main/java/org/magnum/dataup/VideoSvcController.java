package org.magnum.dataup;
import java.io.IOException;
import java.util.Collection;
import java.util.List;
import java.util.UUID;


import java.util.concurrent.CopyOnWriteArrayList;












import javax.servlet.http.HttpServletRequest;


import javax.servlet.http.HttpServletResponse;




//import org.magnum.mobilecloud.video.client.VideoSvcApi;
import org.magnum.dataup.model.Video;
import org.magnum.dataup.model.VideoStatus;
import org.magnum.dataup.model.VideoRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import org.springframework.web.multipart.MultipartFile;

import retrofit.client.Response;
import retrofit.mime.TypedFile;

@Controller
public class VideoSvcController // implements VideoSvcApi  
{

	@Autowired
	private VideoRepository videos;
	private VideoFileManager videoDataMgr;
	
	/* POST /video
   - The video metadata is provided as an application/json request
     body. The JSON should generate a valid instance of the 
     Video class when deserialized by Spring's default 
     Jackson library.
   - Returns the JSON representation of the Video object that
     was stored along with any updates to that object made by the server. 
   - **_The server should generate a unique identifier for the Video
     object and assign it to the Video by calling its setId(...)
     method._** 
   - No video should have ID = 0. All IDs should be > 0.
   - The returned Video JSON should include this server-generated
     identifier so that the client can refer to it when uploading the
     binary mpeg video content for the Video.
   - The server should also generate a "data url" for the
     Video. The "data url" is the url of the binary data for a
     Video (e.g., the raw mpeg data). The URL should be the _full_ URL
     for the video and not just the path (e.g., http://localhost:8080/video/1/data would
     be a valid data url). See the Hints section for some ideas on how to
     generate this URL.

	 */
	@RequestMapping(value=VideoSvcApi.VIDEO_SVC_PATH, method=RequestMethod.POST)
	public @ResponseBody Video addVideo(@RequestBody Video v){
		//		return Video.create().withContentType("video/mp4")
		//				.withDuration(123).withSubject(UUID.randomUUID().toString())
		//				.withTitle(UUID.randomUUID().toString()).build();
		v = videos.addVideo(v);
		v.setDataUrl(getDataUrl(v.getId()));
		return v;
		//return videos.addVideo(v);
	}

	/*
	GET /video
	   - Returns the list of videos that have been added to the
	     server as JSON. The list of videos does not have to be
	     persisted across restarts of the server. The list of
	     Video objects should be able to be unmarshalled by the
	     client into a Collection<Video>.
	   - The return content-type should be application/json, which
	     will be the default if you use @ResponseBody
	 */
	@RequestMapping(value=VideoSvcApi.VIDEO_SVC_PATH, method=RequestMethod.GET)
	public @ResponseBody Collection<Video> getVideoList(){
		//return videos.getVideos();
		Collection<Video> bla = videos.getVideos();
		return bla;
	}
	/* POST /video/{id}/data
   - The binary mpeg data for the video should be provided in a multipart
     request as a part with the key "data". The id in the path should be
     replaced with the unique identifier generated by the server for the
     Video. A client MUST *create* a Video first by sending a POST to /video
     and getting the identifier for the newly created Video object before
     sending a POST to /video/{id}/data. 
   - The endpoint should return a VideoStatus object with state=VideoState.READY
     if the request succeeds and the appropriate HTTP error status otherwise.
     VideoState.PROCESSING is not used in this assignment but is present in VideoState.
   - Rather than a PUT request, a POST is used because, by default, Spring 
     does not support a PUT with multipart data due to design decisions in the
     Commons File Upload library: https://issues.apache.org/jira/browse/FILEUPLOAD-197
	 */
	//@Override
	@RequestMapping(value=VideoSvcApi.VIDEO_DATA_PATH, method=RequestMethod.POST)
	public @ResponseBody ResponseEntity<VideoStatus> setVideoData(
			@PathVariable(VideoSvcApi.ID_PARAMETER) long id,
			@RequestParam(VideoSvcApi.DATA_PARAMETER)MultipartFile videoData) {
		
		try {
			videoDataMgr = VideoFileManager.get();
			Video video = null;
			video = videos.findVidByID(id);
			videoDataMgr.saveVideoData(video, videoData.getInputStream());
		} catch (IOException e) {
			//response.sendError(404, ERROR_MSG);
			// TODO Auto-generated catch block
			e.printStackTrace();
			return null;
		}
		VideoStatus vs = new VideoStatus(VideoStatus.VideoState.READY);
		return new ResponseEntity<VideoStatus>(vs,HttpStatus.OK);
	}

	/*
	GET /video/{id}/data
	   - Returns the binary mpeg data (if any) for the video with the given
	     identifier. If no mpeg data has been uploaded for the specified video,
	     then the server should return a 404 status code.
	 */
	public void  getData(@RequestParam(VideoSvcApi.ID_PARAMETER) long id, HttpServletResponse hsr) {
		// TODO Auto-generated method stub
		try {
			videoDataMgr = VideoFileManager.get();
			Video video = videos.findVidByID(id);
			videoDataMgr.copyVideoData(video, hsr.getOutputStream());
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	 private String getDataUrl(long videoId){
         String url = getUrlBaseForLocalServer() + "/video/" + videoId + "/data";
         return url;
     }

  	private String getUrlBaseForLocalServer() {
  		ServletRequestAttributes sra = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
  		HttpServletRequest request = sra.getRequest();
		   String base = 
		      "http://"+request.getServerName() 
		      + ((request.getServerPort() != 80) ? ":"+request.getServerPort() : "");
		   return base;
		}


}
